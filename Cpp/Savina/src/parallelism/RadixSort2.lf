/**
 * Copyright (C) 2020 TU Dresden
 * 
 * This benchmark implements a radix sorting algorithm for numbers. It iteratively
 * sorts them bit-wise, employing one reactor for each bit position. The
 * `IntSourceReactor` creates a certain amount of random numbers and sends them to
 * the first Sorting Reactor in the chain.
 *
 * Starting with the Least Significant Bit (LSB), each reactor analyzes their
 * assigned bit position in each incoming number and holds back all numbers where
 * the bit is one, sending through all numbers with a zero in the observed
 * position. This will iteratively sort the numbers, like in this example:
 *
 * 111    110    101    001
 * 101    010    001    010
 * 110 -> 111 -> 110 -> 011
 * 011    101    010    101
 * 010    011    111    110
 * 001    001    011    111
 * 
 * @author Hannes Klein
 * @author Felix Wittwer
 * @author Christian Menard
 */


target Cpp {
    build-type : RelWithDebInfo,
    cmake-include : "../IncludeHeaders.cmake"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";


reactor IntSourceReactor(numValues: size_t{100000}, maxValue: uint64_t{{=1l << 60=}}, seed: long{2048}) {
    
    public preamble {=
        #include "PseudoRandom.hh"
    =}
    
    state random: PseudoRandom;
    state numValuesSent: size_t{0};
    
    input start: void;
    
    output outValue: uint64_t;
    
    logical action sendRandomNum;
    
    reaction(start) -> sendRandomNum {=
        // reset local state
        random = PseudoRandom(seed);
        numValuesSent = 0;
        
        // start execution
        sendRandomNum.schedule();
    =}
    
    reaction(sendRandomNum) -> outValue, sendRandomNum {=
        uint64_t value = abs(random.nextLong()) % maxValue;
        reactor::log::Debug() << value;
        outValue.set(value);
        numValuesSent++;
                
        if(numValuesSent < numValues) {
             sendRandomNum.schedule();
        }
    =}
}


reactor SortActor(numValues: size_t{100000}, bank_index: size_t{0}, numBits: size_t{60}) {
    
    state oneBucket: std::vector<uint64_t>;
    state valuesSoFar: size_t{0};
    state radix: uint64_t{{=1ul << bank_index=}};
    
    input start: void; 
    input inValue: uint64_t;
    output outValue: uint64_t;

    state readPos: size_t{0};    
    logical action sendBufferedValues;
    
    logical action sendValue: uint64_t;

    reaction (sendValue) -> outValue {=
        outValue.set(std::move(sendValue.get()));
    =}

    reaction(sendBufferedValues) -> outValue, sendBufferedValues {=
        if (outValue.is_present()) {
            sendBufferedValues.schedule();   
        } else {
            if (readPos < oneBucket.size()) {
                outValue.set(oneBucket[readPos]);
                readPos++;
                sendBufferedValues.schedule();
            }
        }
    =}

    reaction(inValue) -> sendValue, sendBufferedValues {=
        valuesSoFar++;
        
        uint64_t current = *inValue.get();
        if(current & radix) {
            // if the digit is one, we put the value to our local bucket
            oneBucket.push_back(current);
        } else {
            // if the digit is zero, we pipe the value through
            sendValue.schedule(current);
        }
        
        if(valuesSoFar == numValues) {
            if (!oneBucket.empty()) {
                sendBufferedValues.schedule();
            }
        }
    =}
        
    reaction(startup) {=
        oneBucket.reserve(numValues);
    =}
    
    reaction(start) {=
         // reset local state
         valuesSoFar = 0;
         readPos = 0;
         oneBucket.clear();
    =}
}

reactor ValidationReactor(numValues: size_t{100000}) {

    state sumSoFar: double{0.0};
    state valuesSoFar: size_t{0};
    state prevValue: uint64_t{0};
    state errorValueLong: {=long=}(-1);
    state errorValueInt:int(-1);
    
    input inValue: uint64_t
    output outFinished: void
    
    reaction(inValue) -> outFinished {=
        
        uint64_t value = *inValue.get();
        
        if(value < prevValue) {
            reactor::log::Error() << "ERROR: Value out of place: " << value << " at index " << valuesSoFar;
            errorValueLong = value;
            errorValueInt = valuesSoFar - 1;
        }
        
        valuesSoFar++;
        prevValue = value;
        sumSoFar += prevValue;
        
        if(valuesSoFar == numValues) {
            reactor::log::Info() << "Elements sum: " << sumSoFar;
            
            // reset local state
            sumSoFar = 0.0;
            valuesSoFar = 0;
            prevValue = 0;

            outFinished.set();
        }
    =}
}

main reactor (numIterations: size_t{12}, dataSize: size_t{100000}, maxValue: uint64_t({=1l << 60=}), numBits: size_t{60}, seed: long{2048}) {
    
    source = new IntSourceReactor(numValues=dataSize, maxValue=maxValue, seed=seed);
    validator = new ValidationReactor(numValues=dataSize);
    runner = new BenchmarkRunner(numIterations=numIterations);
    sorters = new[numBits] SortActor(numValues=dataSize, numBits=numBits);
    
    (runner.start)+ -> source.start, sorters.start;
    validator.outFinished -> runner.finished;
    
    source.outValue, sorters.outValue -> sorters.inValue, validator.inValue;
    
    reaction(startup) {=
        printBenchmarkInfo("RadixSortBenchmark");
        printArgs("numIterations", numIterations, "dataSize", dataSize, "maxValue", maxValue, "seed", seed);
        printSystemInfo();
    =}
}