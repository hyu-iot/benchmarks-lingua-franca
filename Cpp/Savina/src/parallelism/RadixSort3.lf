/**
 * Copyright (C) 2020 TU Dresden
 * 
 * This benchmark implements a radix sorting algorithm for numbers. It iteratively
 * sorts them bit-wise, employing one reactor for each bit position. The
 * `IntSourceReactor` creates a certain amount of random numbers and sends them to
 * the first Sorting Reactor in the chain.
 *
 * Starting with the Least Significant Bit (LSB), each reactor analyzes their
 * assigned bit position in each incoming number and holds back all numbers where
 * the bit is one, sending through all numbers with a zero in the observed
 * position. This will iteratively sort the numbers, like in this example:
 *
 * 111    110    101    001
 * 101    010    001    010
 * 110 -> 111 -> 110 -> 011
 * 011    101    010    101
 * 010    011    111    110
 * 001    001    011    111
 * 
 * @author Hannes Klein
 * @author Felix Wittwer
 * @author Christian Menard
 */


target Cpp {
    build-type : RelWithDebInfo,
    cmake-include : "../IncludeHeaders.cmake",
    fast: "true",
};

import BenchmarkRunner from "../BenchmarkRunner.lf";


reactor IntSourceReactor(numValues: size_t{100000}, maxValue: uint64_t{{=1l << 60=}}, seed: long{2048}) {
    
    public preamble {=
        #include "PseudoRandom.hh"
    =}
    
    state random: PseudoRandom;
    state numValuesSent: size_t{0};
    
    input start: void;
    
    output outValue: uint64_t;
    
    logical action sendRandomNum;
    
    reaction(start) -> sendRandomNum {=
        // reset local state
        random = PseudoRandom(seed);
        numValuesSent = 0;
        
        // start execution
        sendRandomNum.schedule();
    =}
    
    reaction(sendRandomNum) -> outValue, sendRandomNum {=
        uint64_t value = abs(random.nextLong()) % maxValue;
        reactor::log::Debug() << value;
        outValue.set(value);
        numValuesSent++;
                
        if(numValuesSent < numValues) {
             sendRandomNum.schedule();
        }
    =}
}


reactor SortActor(numValues: size_t{100000}, bank_index: size_t{0}, numBits: size_t{60}) {
    
    state oneBucket: std::vector<uint64_t>;
    state valuesSoFar: size_t{0};
    state radix: uint64_t{{=1ul << bank_index=}};
    state current_value: uint64_t{0};
    state value_to_send: bool{false};
    state send_buffered_values: bool{false};
    
    input start: void; 
    input inValue: uint64_t;
    output outValue: uint64_t;
    
    input tick: void
       
    state readPos: size_t{0};    
    logical action sendBufferedValues;

    reaction(inValue) {=
        valuesSoFar++;
        
        current_value = *inValue.get();
        if(current_value & radix) {
            // if the digit is one, we put the value to our local bucket
            oneBucket.push_back(current_value);
        } else {
            // if the digit is zero, we pipe the value through
            value_to_send = true;
        }
        
        if(valuesSoFar == numValues) {
            send_buffered_values = true;
        }
    =}
    
    reaction (tick) -> outValue {=
        if (value_to_send) {
            value_to_send = false;
            outValue.set(value_to_send);            
        } else if (send_buffered_values && readPos < oneBucket.size()) {
            outValue.set(oneBucket[readPos]);
            readPos++;
        }
    =}
            
    reaction(startup) {=
        oneBucket.reserve(numValues);
    =}
    
    reaction(start) {=
         // reset local state
         valuesSoFar = 0;
         readPos = 0;
         value_to_send = false;
         send_buffered_values = false;
         oneBucket.clear();
    =}
}

reactor Clock {
    input start: void;
    input stop: void;
    
    output tick: void;
    logical action tock;
    
    state enabled: bool{false}; 
    
    reaction (tock) -> tick, tock {=
        tick.set();
        if (enabled) {
            tock.schedule();
        }
    =}
    
    reaction (start) -> tock {=
        enabled = true;
        tock.schedule();
    =}
    
    reaction (stop) {=
        enabled = false;
    =}
}

reactor ValidationReactor(numValues: size_t{100000}) {

    state sumSoFar: double{0.0};
    state valuesSoFar: size_t{0};
    state prevValue: uint64_t{0};
    state errorValueLong: {=long=}(-1);
    state errorValueInt:int(-1);
    
    input inValue: uint64_t
    output outFinished: void
    
    reaction(inValue) -> outFinished {=
        
        uint64_t value = *inValue.get();
        
        if(value < prevValue) {
            reactor::log::Error() << "ERROR: Value out of place: " << value << " at index " << valuesSoFar;
            errorValueLong = value;
            errorValueInt = valuesSoFar - 1;
        }
        
        valuesSoFar++;
        prevValue = value;
        sumSoFar += prevValue;
        
        if(valuesSoFar == numValues) {
            reactor::log::Info() << "Elements sum: " << sumSoFar;
            
            // reset local state
            sumSoFar = 0.0;
            valuesSoFar = 0;
            prevValue = 0;

            outFinished.set();
        }
    =}
}

main reactor (numIterations: size_t{12}, dataSize: size_t{100000}, maxValue: uint64_t({=1l << 60=}), numBits: size_t{60}, seed: long{2048}) {
    
    source = new IntSourceReactor(numValues=dataSize, maxValue=maxValue, seed=seed);
    validator = new ValidationReactor(numValues=dataSize);
    runner = new BenchmarkRunner(numIterations=numIterations);
    sorters = new[numBits] SortActor(numValues=dataSize, numBits=numBits);
    clock = new Clock();
    
    (runner.start)+ -> source.start, clock.start, sorters.start;
    (validator.outFinished)+ -> runner.finished, clock.stop;
    
    (clock.tick)+ -> sorters.tick;
    
    source.outValue, sorters.outValue -> sorters.inValue, validator.inValue;
    
    reaction(startup) {=
        printBenchmarkInfo("RadixSortBenchmark");
        printArgs("numIterations", numIterations, "dataSize", dataSize, "maxValue", maxValue, "seed", seed);
        printSystemInfo();
    =}
}