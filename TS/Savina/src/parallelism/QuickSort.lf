/**
 *  Savina benchmark: Quicksort
 *  
 *  @author Yunsang Cho 
 *  @author Byungkeun Choi
 *  @author Wonseo Choi
 */

 target TypeScript {
    fast: true
};

//import BenchmarkRunner from "../BenchmarkRunner.lf";

reactor QuickSort_Unit(capacity: number(2048), data: {=Array<number>=}({=[]=}), given_position: {=Pos=}({=Pos.INIT=})){

    input sort_in:{=Array<number>=};
    input result_in:{=Array<number>=};
    output sort_out:{=Array<number>=};
    output result_out:{=Array<number>=};

    output result:{=Array<number>=};
    state num_fragment:number(0);
    state current:{=Array<number>=}({=[]=});
    state pivot:number;
    preamble {=

        function filter_less_than(data:Array<number>, pivot:number): Array<number> {
            const result: number[] = [];
            data.forEach(element => {
                if (element < pivot)    result.push(element);
            });
            return result;
        }
        function filter_eqauls_to(data:Array<number>, pivot:number): Array<number> {
            const result: number[] = [];
            data.forEach(element => {
                if (element == pivot)    result.push(element);
            });
            return result;
        }
        function filter_between(data:Array<number>, left_pivot:number, right_pivot:number): Array<number> {
            const result: number[] = [];
            data.forEach(element => {
                if (element >= left_pivot && element <= right_pivot)    result.push(element);
            });
            return result;
        }
        function filter_greater_than(data:Array<number>, pivot:number): Array<number> {
            const result: number[] = [];
            data.forEach(element => {
                if (element > pivot)    result.push(element);
            });
            return result;
        }
        function quicksort_seq(data:Array<number>): Array<number> {
            if (data.length < 2)    return data;
            const pivot:number = data[Math.floor(data.length/2)];
            const left_unsorted:number[] = filter_less_than(data, pivot);
            const left_sorted:number[] = quicksort_seq(left_unsorted);
            const equal_elements:number[] = filter_eqauls_to(data, pivot);
            const right_unsorted:number[] = filter_greater_than(data, pivot);
            const right_sorted:number[] = quicksort_seq(right_unsorted);
            const sorted_array:number[] = [...left_sorted, ...equal_elements, ...right_sorted];
            return sorted_array;
        }
    =}


    reaction(startup) {=
        console.log("Result: ", quicksort_seq(data));
    =}

    mutation(sort_in, result_in) -> sort_out, result_out {=
        if (sort_in) {
            data = sort_in as Array<number>;
            if (data.length < capacity) {
              result_out = quicksort_seq(data)
              // TODO: "delete"       
            } else {
                pivot = data[Math.floor(data.length/2)];
                const left_unsorted = filter_less_than(data, pivot);
                const right_unsorted = filter_greater_than(data, pivot);
                let left_reactor = new QuickSort_Unit(this.getReactor(), capacity, left_unsorted, Pos.LEFT);
                let right_reactor = new QuickSort_Unit(this.getReactor(), capacity, right_unsorted, Pos.RIGHT);
                
                var result_out_port = __result_out.getPort();
                this.connect(result_out_port , left_reactor.result_in);
                this.connect(result_out_port , right_reactor.result_in);
                var sort_out_port = __sort_out.getPort();
                this.connect(sort_out_port , left_reactor.sort_in);
                this.connect(sort_out_port , right_reactor.sort_in);
                // Not allowed -> effect determinism
                // var result_in_port = __result_in.getPort();
                // this.connect(left_reactor.sort_out , result_in_port);
                // this.connect(right_reactor.sort_out , result_in_port);
                current = filter_eqauls_to(data, pivot);
                num_fragment++;
            }
        }

        if (result_in) {
            if (result_in.length) {
                if (given_position === Pos.LEFT) {
                    current = [...result_in, ...current];
                } else if (given_position === Pos.RIGHT) {
                    current = [...current, ...result_in];
                }
            }
            num_fragment++;
            if (num_fragment == 3) {
                result_out = current;
            }

        }
    =}
}

reactor Source(num_data:number(1000000), max_value:number(0)) {
    input start:boolean;
    output end:boolean;
    output result_msg:{=Array<number>=};
    input final_result:{=Array<number>=};
    output sort_msg:{=Array<number>=}
    
    reaction(start) -> sort_msg, result_msg {=
        sort_msg = new Array<number>(num_data);
        //sort_msg.fill(0).map(() => Math.floor(Math.random() * num_data))
        for(var i = 0; i< sort_msg.length; i++){
            sort_msg[i] = i;
        }
        for (let index = sort_msg.length - 1; index > 0; index--) {
            // 무작위 index 값을 만든다. (0 이상의 배열 길이 값)
            const randomPosition = Math.floor(Math.random() * (index + 1));
            // 임시로 원본 값을 저장하고, randomPosition을 사용해 배열 요소를 섞는다.
            const temporary = sort_msg[index];
            sort_msg[index] = sort_msg[randomPosition];
            sort_msg[randomPosition] = temporary;
        }
        console.log(`Before: ${sort_msg}`);
        result_msg = new Array<number>(1);
    =}

    reaction(final_result) -> end {=
        var result:Array<number> = final_result as Array<number>;
        console.log(`Final result: ${result}`);
        end = true;
    =}


}

main reactor QuickSort(num_iterations: number(12)) {
    preamble {=
        enum Pos {INIT, RIGHT, LEFT};
        let position:Pos;
    =}
    logical action end;
    state startTime: time;
    //runner = new BenchmarkRunner(numIterations = num_iterations);
    source = new Source(num_data = 2048, max_value = 0);
    unit = new QuickSort_Unit(capacity=2048, data={=[4, 1, 3, 2]=}, given_position = {=Pos.INIT=});

    //runner.start -> source.start;
    reaction (startup)->source.start{=
        source.start = true;
    =}
    reaction (source.end) {=
        if (startTime) {
            let elapsedTime = util.getCurrentPhysicalTime().subtract(startTime);
            console.log("Elapsed time: " + elapsedTime);
            util.requestStop();
        }
    =}  
    (source.sort_msg)+ -> unit.sort_in, unit.result_in;
    unit.result_out -> source.final_result;
    //source.end -> runner.finish;

}