/**
 *  Savina benchmark: Matmul
 *  
 *  @author Byungkeun Choi
 */

target TypeScript {
    fast: true
};


reactor Manager(numWorkers: number(20), dataLength: number(1024)) {
    preamble{=
        type WorkItem = {
            srA:number;
            scA:number;
            srB:number;
            scB:number;
            srC:number;
            scC:number;
            numberofblocks:number;
            dim:number;
        }

    =}
    
    state A:{=Array<number>=}({=[]=});
    state B:{=Array<number>=}({=[]=});
    state C:{=Array<number>=}({=[]=});
    

    state workQueue: {=Array<WorkItem>=}({=[]=});
    
    logical action next;
    logical action done;
    
    input start: void;
    output finished: void;
    
    //output data: {=std::tuple<const Matrix<double>*, const TransposedMatrix<double>*, Matrix<double>*>=};
    output data: {=Array<Array<number>>=};
    output[numWorkers] doWork: WorkItem;
    //input[numWorkers] moreWork: {=std::array<reactor::ImmutableValuePtr<WorkItem>, 8>=};
    input[numWorkers] moreWork: {=Array<WorkItem>=};
    reaction (startup) {=
        A = new Array<number>(dataLength);
        for(var i = 0; i < A.length; i++){
            A[i] = new Array<number>(dataLength) as any;
        }        
        B = new Array<number>(dataLength);
        for(var i = 0; i < B.length; i++){
            B[i] = new Array<number>(dataLength) as any;
        }
        // Fill both input arrays with data
        for (let i = 0; i < dataLength; i++) {
            for (let j = 0; j < dataLength; j++) {
                A[i][j] = i;
                B[i][j] = j;
            }
        }
    =}
    
    reaction (start) -> data, next {=
        // reset the result matrix C
        //C = Matrix<double>(dataLength, dataLength);
        
        C = new Array<number>(dataLength);
        for(var i = 0; i < C.length; i++){
            C[i] = new Array<number>(dataLength) as any;
        }
        // send pointers to all 3 matrixes to the workers
        //data.set(std::make_tuple(&A, &B, &C));
        data[0] = A;
        data[1] = B;
        data[2] = C;
        // produce the first work item, instructing the worker to multiply the complete matrix
        var numBlocks:number = dataLength * dataLength;
        var item:WorkItem = {srA:0, scA:0, srB:0, scB:0, srC:0, scC:0, numberofblocks:numBlocks, dim: dataLength};
        //workQueue.emplace_back(std::move(item));
        workQueue.push(item);
        // and start the first iteration
        next = true;
    =}
    
    reaction (next) -> next, done, doWork {=
        if (workQueue.length == 0){
            // we are done if there is no more work
            done = true;
        } else {
            // send a work item to each worker (until there is no more work)
            for (var i = 0; i < numWorkers && workQueue.length!=0; i++) {
                doWork[i] = workQueue[0];
                workQueue.shift();
            }
            // and schedule the next iteration
            next = true;
        }
    =}
    
    reaction (moreWork) {=
        // append all work items received from the workers to the internal work queue
        workQueue.concat(moreWork);
    =}
    

    reaction (done) -> finished {=
        var valid:boolean = isValid();
        //reactor::log::Info() << std::boolalpha << "Result valid = " << valid << std::noboolalpha;
        console.log("Result valid = " + valid);
        finished = true;
    =}
    
    const method isValid():boolean {=
        for (var i = 0; i < dataLength; i++) {
            for (var j = 0; j < dataLength; j++) {
                var actual:number = C[i][j];
                var expected:number = 1.0 * dataLength * i * j;
                if (Math.abs(actual-expected) > 0.0001) { // allow some rounding errors
                    //reactor::log::Info() << "Validation failed for (i,j)=" << i << "," << j << " with (" << actual << "," << expected << ")";
                    console.log("Validation failed for (i,j)=" + i + "," + j + "with (" + actual + "," + expected + ")" );
                    return false;    
                }
            }
        }
        return true;
    =}
}

reactor Worker(threshold: number(16384)) {
    
    // state A: {=const Matrix<double>*=};
    // state B: {=const TransposedMatrix<double>*=};
    // state C: {=Matrix<double>*=};
    
    state A:{=Array<number>=}({=[]=});
    state B:{=Array<number>=}({=[]=});
    state C:{=Array<number>=}({=[]=});
    //input data: {=std::tuple<const Matrix<double>*, const TransposedMatrix<double>*, Matrix<double>*>=};
    input data: {=Array<Array<number>>=};
    input doWork: WorkItem;    
    
    //output moreWork: {=std::array<reactor::ImmutableValuePtr<WorkItem>, 8>=};
    output moreWork: {=Array<WorkItem>=};
    reaction (data) {=
        var tuple:any = data;
        A = tuple[0];
        B = tuple[1];
        C = tuple[2];
    =}
    
    reaction(doWork) -> moreWork {=
        var wi:WorkItem = doWork;
        // If the number of blocks to process is above the threshold,
        // then we split the problem into smaller chunks and generate more work items
        if (wi.numberofblocks > threshold) {
            var workQueue = new Array<WorkItem>(8);
            var dimm:number = wi.dim / 2;
            var numBlocks:number = wi.numberofblocks / 4;
            workQueue[0] = {srA:wi.srA      , scA:wi.scA      , srB:wi.srB      , scB:wi.scB      , srC:wi.srC      , scC:wi.scC      , numberofblocks:numBlocks, dim:dimm};
            workQueue[1] = {srA:wi.srA      , scA:wi.scA + dimm, srB:wi.srB + dimm, scB:wi.scB      , srC:wi.srC      , scC:wi.scC      , numberofblocks:numBlocks, dim:dimm};
            workQueue[2] = {srA:wi.srA      , scA:wi.scA      , srB:wi.srB      , scB:wi.scB + dimm, srC:wi.srC      , scC:wi.scC + dimm, numberofblocks:numBlocks, dim:dimm};
            workQueue[3] = {srA:wi.srA      , scA:wi.scA + dimm, srB:wi.srB + dimm, scB:wi.scB + dimm, srC:wi.srC      , scC:wi.scC + dimm, numberofblocks:numBlocks, dim:dimm};
            workQueue[4] = {srA:wi.srA + dimm, scA:wi.scA      , srB:wi.srB      , scB:wi.scB      , srC:wi.srC + dimm, scC:wi.scC      , numberofblocks:numBlocks, dim:dimm};
            workQueue[5] = {srA:wi.srA + dimm, scA:wi.scA + dimm, srB:wi.srB + dimm, scB:wi.scB      , srC:wi.srC + dimm, scC:wi.scC      , numberofblocks:numBlocks, dim:dimm};
            workQueue[6] = {srA:wi.srA + dimm, scA:wi.scA      , srB:wi.srB      , scB:wi.scB + dimm, srC:wi.srC + dimm, scC:wi.scC + dimm, numberofblocks:numBlocks, dim:dimm};
            workQueue[7] = {srA:wi.srA + dimm, scA:wi.scA + dimm, srB:wi.srB + dimm, scB:wi.scB + dimm, srC:wi.srC + dimm, scC:wi.scC + dimm, numberofblocks:numBlocks, dim:dimm};
            moreWork = workQueue;
        } else {
            // otherwise we compute the result directly
            var endR:number = wi.srC + wi.dim;
            var endC:number = wi.scC + wi.dim;
        
            for (let i = wi.srC; i < endR; i++) {
                for (let j = wi.scC; j < endC; j++) {
                    for (let k = 0; k < wi.dim; k++) {
                        C[i][j] += A[i][wi.scA + k] * B[wi.srB + k][j];
                    }
                }
            }
        }
    =}
}

main reactor (numIterations: number(12), dataLength: number(1024), blockThreshold: number(16384), priorities:number(10), numWorkers: number(20)) {

    // The priorities parameter is not used, but we keep it for compatibility with Akka
    manager = new Manager(numWorkers=numWorkers, dataLength=dataLength);
    workers = new[numWorkers] Worker(threshold=blockThreshold) 
    state startTime: time;
    
    reaction(startup) ->manager.start {=        
        printBenchmarkInfo("MatMulBenchmark");
        printArgs("numIterations", numIterations, "dataLength", dataLength, "blockThreshold", blockThreshold, "priorities", priorities, "numWorkers", numWorkers);
        printSystemInfo();
        
    =}
    reaction (manager.finished) {=
        if (startTime) {
            let elapsedTime = util.getCurrentPhysicalTime().subtract(startTime);
            console.log("Elapsed time: " + elapsedTime);
            util.requestStop();
        }
    =}  
    (manager.data)+ -> workers.data;
    manager.doWork -> workers.doWork;
    workers.moreWork -> manager.moreWork;
}
