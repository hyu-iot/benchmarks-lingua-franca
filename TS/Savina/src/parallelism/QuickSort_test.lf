/**
 *  Savina benchmark: Quicksort
 *  
 *  @author Yunsang Cho 
 *  @author Byungkeun Choi
 *  @author Wonseo Choi
 */

 target TypeScript {
    fast: true
};

//import BenchmarkRunner from "../BenchmarkRunner.lf";

reactor QuickSort_Unit(capacity: number(2048), data: {=Array<number>=}({=[]=}) , my_position: {=Pos=}({=Pos.INIT=}), pivot_array: {=Array<number>=}({=[]=}), num_fragment: number(0)){

    input sort_in:{=Array<number>=};
    input result_in_LEFT:{=Array<number>=};
    input result_in_RIGHT:{=Array<number>=};
    input merge_in_LEFT:{=Array<number>=};
    input merge_in_RIGHT:{=Array<number>=};
    output sort_out_LEFT:{=Array<number>=};
    output sort_out_RIGHT:{=Array<number>=};
    output merge_out:{=Array<number>=};
    //output new_result:{=Array<number>=};
    //state num_fragment:number(0);
    state current:{=Array<number>=}({=[]=});
    state pivot:number;

    preamble {=
        function filter_less_than(data:Array<number>, pivot:number): Array<number> {
            const result: number[] = [];
            data.forEach(element => {
                if (element < pivot)    result.push(element);
            });
            return result;
        }
        function filter_eqauls_to(data:Array<number>, pivot:number): Array<number> {
            const result: number[] = [];
            data.forEach(element => {
                if (element == pivot)    result.push(element);
            });
            return result;
        }
        function filter_between(data:Array<number>, left_pivot:number, right_pivot:number): Array<number> {
            const result: number[] = [];
            data.forEach(element => {
                if (element >= left_pivot && element <= right_pivot)    result.push(element);
            });
            return result;
        }
        function filter_greater_than(data:Array<number>, pivot:number): Array<number> {
            const result: number[] = [];
            data.forEach(element => {
                if (element > pivot)    result.push(element);
            });
            return result;
        }
        function quicksort_seq(data:Array<number>): Array<number> {
            if (data.length < 2)    return data;
            const pivot:number = data[Math.floor(data.length/2)];
            const left_unsorted:number[] = filter_less_than(data, pivot);
            const left_sorted:number[] = quicksort_seq(left_unsorted);
            const equal_elements:number[] = filter_eqauls_to(data, pivot);
            const right_unsorted:number[] = filter_greater_than(data, pivot);
            const right_sorted:number[] = quicksort_seq(right_unsorted);
            const sorted_array:number[] = [...left_sorted, ...equal_elements, ...right_sorted];
            return sorted_array;
        }
    =}


    reaction(startup) {=
        //console.log("Result: ", quicksort_seq(data));
    =}

    mutation(sort_in, merge_in_LEFT, merge_in_RIGHT) -> sort_out_LEFT, sort_out_RIGHT, merge_out{=
        current = pivot_array;
        if (sort_in) {
            data = sort_in as Array<number>;
            if (data.length <= capacity) {
                if(my_position == Pos.LEFT){
                    sort_out_LEFT = quicksort_seq(data);
                
                }
                else if(my_position == Pos.RIGHT){
                    sort_out_RIGHT = quicksort_seq(data);
                }
                
                //console.log("Sorted_result: ", result_out);
                //need to check using log

            } else {
                pivot = data[Math.floor(data.length/2)];
                const left_unsorted = filter_less_than(data, pivot);
                const right_unsorted = filter_greater_than(data, pivot);
                let left_reactor = new QuickSort_Unit(this.getReactor(), capacity, left_unsorted, Pos.LEFT, [], 0);
                let right_reactor = new QuickSort_Unit(this.getReactor(), capacity, right_unsorted, Pos.RIGHT,[], 0);
                sort_out_LEFT = left_unsorted;
                sort_out_RIGHT = right_unsorted;
                var sort_out_LEFT_port = __sort_out_LEFT.getPort();
                var sort_out_LEFT_port = __sort_out_RIGHT.getPort();
                this.connect(sort_out_LEFT_port, left_reactor.sort_in);
                this.connect(sort_out_RIGHT_port, right_reactor.sort_in);
                this.connect(left_reactor.merge_out, merge_in_LEFT);
                this.connect(right_reactor.merge_out, merge_in_RIGHT);
                // this.connect(sort_out1_port , left_reactor.sort_in);
                // this.connect(sort_out2_port , right_reactor.sort_in);
                pivot_array = filter_eqauls_to(data, pivot);
                
            }       
        }
        if (merge_in_LEFT) { 
            // let parent = new QuickSort_Unit(this.getReactor(), capacity, current, Pos.LEFT,pivot_array, 0);
            // var merge_out_port = __result_out.getPort();  
            // this.connect(result_out_port, parent.result_in_LEFT);
            console.log("Result_in_LEFT:", merge_in_LEFT);
            current = [...merge_in_LEFT, ...pivot_array];
            leftcount++;
            num_fragment++;
            //need to check using log
            
            if (num_fragment == 2) {
                //need to check using log
                console.log("Merged_result: ", merge_out);
                
                merge_out = current;
            }
            
            console.log("numFragment: ", num_fragment);
            console.log("LeftCount: ", leftcount);
            console.log("RightCount: ", rightcount);
            
        }
        if (merge_in_RIGHT) {
            // let parent = new QuickSort_Unit(this.getReactor(), capacity, current, pivot_array, 0);
            // var result_out_port = __result_out.getPort();
            // this.connect(result_out_port, parent.result_in_RIGHT);
            console.log("Result_in_RIGHT:", merge_in_RIGHT);
            current = [...pivot_array, ...merge_in_RIGHT];
            rightcount++;
            num_fragment++;
            //need to check using log
            
            if (num_fragment == 2) {
                //need to check using log
                merge_out = current;
                console.log("Merged_result: ", merge_out);
            }
            console.log("numFragment: ", num_fragment);
            console.log("LeftCount: ", leftcount);
            console.log("RightCount: ", rightcount);
        }
    =}
}

// reactor Merger(capacity: number(2048), data: {=Array<number>=}({=[]=}), pivot_array: {=Array<number>=}({=[]=}), num_fragment: number(0)){
//     input merge_in_LEFT:{=Array<number>=};
//     input merge_in_RIGHT:{=Array<number>=};
//     output merge_out:{=Array<number>=};
//     state leftcount:number(0);
//     state rightcount:number(0);
//     state current:{=Array<number>=}({=[]=});
    
//     mutation(merge_in_LEFT, merge_in_RIGHT) -> merge_out{=

//         if (result_in_LEFT) { 
//             let parent = new Merger(this.getReactor(), capacity, current, pivot_array, 0);
//             var merge_out_port = __result_out.getPort();  
//             this.connect(result_out_port, parent.result_in_LEFT);
//             console.log("Result_in_LEFT:", result_in_LEFT);
//             current = [...result_in_LEFT, ...pivot_array];
//             leftcount++;
//             num_fragment++;
//             //need to check using log
            
//             if (num_fragment == 2) {
//                 //need to check using log
//                 console.log("Merged_result: ", result_out);
                
//                 result_out = current;
//             }
            
//             console.log("numFragment: ", num_fragment);
//             console.log("LeftCount: ", leftcount);
//             console.log("RightCount: ", rightcount);
            
//         }
//         if (result_in_RIGHT) {
//             if(num_fragment==0){
//                 let parent = new Merger(this.getReactor(), capacity, current, pivot_array, 0);
//             }
//             var result_out_port = __result_out.getPort();
//             if(parent.result_in_RIGHT!=undefined)
//                 this.connect(result_out_port, parent.result_in_RIGHT);
//             console.log("Result_in_RIGHT:", result_in_RIGHT);
//             current = [...pivot_array, ...result_in_RIGHT];
//             rightcount++;
//             num_fragment++;
//             //need to check using log
            
//             if (num_fragment == 2) {
//                 //need to check using log
//                 result_out = current;
//                 console.log("Merged_result: ", result_out);
//             }
//             console.log("numFragment: ", num_fragment);
//             console.log("LeftCount: ", leftcount);
//             console.log("RightCount: ", rightcount);
//         }
    
//     =}
// }

reactor Source(num_data:number(1000000), max_value:number(0), final_result:{=Array<number>=}({=[]=})) {
    input start:boolean;
    input result:{=Array<number>=};
    output end:boolean;
    output result_msg:{=Array<number>=};
    output sort_msg:{=Array<number>=}
    state new_array:{=Array<number>=}({=[]=});

    // input merge1:{=Array<number>=};
    // input merge2:{=Array<number>=};
    // output merged:{=Array<number>=};

    reaction(start) -> sort_msg, result_msg{=
        sort_msg = new Array<number>(num_data);
        //sort_msg.fill(0).map(() => Math.floor(Math.random() * num_data))
        for(var i = 0; i< sort_msg.length; i++){
            sort_msg[i] = i;
        }
        for (let index = sort_msg.length - 1; index > 0; index--) {
            // make random index value. (has array length longer than 0 )
            const randomPosition = Math.floor(Math.random() * (index + 1));
            // save the original value on temp, and mix the array elements using randomPosition.
            const temporary = sort_msg[index];
            sort_msg[index] = sort_msg[randomPosition];
            sort_msg[randomPosition] = temporary;
        }
        console.log("Before: " + sort_msg);
        result_msg = new Array<number>(1);
    =}

    // reaction(merge1, merge2,) -> merged{
    //     if(merge1)
    //         array_to_merge1 = merge1;
    //     if(merge2)
    //         array_to_merge2 = merge2;
    //     merged:
    // }
    
    reaction(result) -> end{=
        end = true;
        console.log("Final result: " + result)
    =}


}

main reactor QuickSort_test(num_iterations: number(12)) {
    preamble {=
        enum Pos {INIT, RIGHT, LEFT};
        let position:Pos;
    =}
    state startTime: time;
    //runner = new BenchmarkRunner(numIterations = num_iterations);
    source = new Source(num_data = 50, max_value = 0, final_result={=[]=});
    unit = new QuickSort_Unit(capacity=10, data={=[]=}, my_position = {=Pos.INIT=}, pivot_array={=[]=}, num_fragment=0);
    //runner.start -> source.start;
    reaction (startup)->source.start{=
        source.start = true;
    =}

    // //No need
    reaction (source.end) {=
        if (startTime) {
            let elapsedTime = util.getCurrentPhysicalTime().subtract(startTime);
            console.log("Elapsed time: " + elapsedTime);
            util.requestStop();
        }
    =}  

    source.sort_msg -> unit.sort_in;
    (source.result_msg)+ -> unit.result_in_LEFT, unit.result_in_RIGHT;
    unit.sort_out_LEFT -> unit.merge_in_LEFT
    unit.sort_out_RIGHT -> unit.merge_in_RIGHT;
    unit.merge_out -> source.result;
    //source.end -> runner.finish;

}