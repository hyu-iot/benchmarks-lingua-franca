/**
 *  Savina benchmark: Quicksort
 *  
 *  @author Yunsang Cho 
 */

 target TypeScript {
    fast: true
};

import BenchmarkRunner from "BenchmarkRunner.lf";

preamble {=
    enum Pos {INIT, RIGHT, LEFT};
    type RESULT_MSG_TYPE {
            let position:Pos = Pos.INIT;
            let data:Array<number>;
    };
=}



reactor QuickSort_Unit(capacity: number(2048), data: {=Array<number>=}({=[]=}), given_position: {=Pos=}({=Pos.INIT=})){
    input sort_msg:boolean;
    input result_msg:{=RESULT_MSG_TYPE=};
    output result:{=RESULT_MSG_TYPE=};
    state num_fragment:number(0);
    state current:{=Array<number>=}({=[]=});
    state pivot:number;
    
    preamble {=

        function filter_less_than(data:Array<number>, pivot:number): Array<number> {
            const result: number[] = [];
            data.forEach(element => {
                if (element < pivot)    result.push(element);
            });
            return result;
        }
        function filter_eqauls_to(data:Array<number>, pivot:number): Array<number> {
            const result: number[] = [];
            data.forEach(element => {
                if (element == pivot)    result.push(element);
            });
            return result;
        }
        function filter_between(data:Array<number>, left_pivot:number, right_pivot:number): Array<number> {
            const result: number[] = [];
            data.forEach(element => {
                if (element >= left_pivot && element <= right_pivot)    result.push(element);
            });
            return result;
        }
        function filter_greater_than(data:Array<number>, pivot:number): Array<number> {
            const result: number[] = [];
            data.forEach(element => {
                if (element > pivot)    result.push(element);
            });
            return result;
        }
        function quicksort_seq(data:Array<number>): Array<number> {
            if (data.length < 2)    return data;
            const pivot:number = data[Math.floor(data.length/2)];
            const left_unsorted:number[] = filter_less_than(data, pivot);
            const left_sorted:number[] = quicksort_seq(left_unsorted);
            const equal_elements:number[] = filter_eqauls_to(data, pivot);
            const right_unsorted:number[] = filter_greater_than(data, pivot);
            const right_sorted:number[] = quicksort_seq(right_unsorted);
            const sorted_array:number[] = [...left_sorted, ...equal_elements, ...right_sorted];
            return sorted_array;
        }
    =}


    reaction(startup) {=
        console.log("Result: ", quicksort_seq(data));
        result_msg.position = given_position;
    =}

    mutation(sort_msg, result_msg) -> result {=
        if (sort_msg) {
            if (capacity < data.length) {
              result = quicksort_seq(data)
              
            } else {
                pivot = data[Math.floor(data.length/2)];
                const left_unsorted = filter_less_than(data, pivot);
                const right_unsorted = filter_greater_than(data, pivot);
                let left_reactor = new QuickSort_Unit(this.getReactor(), capacity, left_unsorted, Pos.LEFT);
                let right_reactor = new QuickSort_Unit(this.getReactor(), capacity, right_unsorted, Pos.RIGHT);
                
                var sort_msg_port = __sort_msg.getPort();
                var result_msg_port = __result_msg.getPort();

                //this.connect(자기자신 뭐시기, left_reactor의 sort_msg)
                this.connect(sortMsgPort. , left_reactor.sort_msg);
                //this.connect(자기자신 뭐시기, right_reactor의 sort_msg)
                this.connect(sortMsgPort , right_reactor.sort_msg);
                //this.connect(left_reactor의 result, 자기 자신의 result_msg)
                this.connect(resultMsgPort , left_reactor.result_msg);
                //this.connect(right_reactor의 result, 자기 자신의 result_msg)
                this.connect(resultMsgPort , right_reactor.result_msg);

                current = filter_eqauls_to(data, pivot);
                num_fragment++;
            }
        }

        if (result_msg) {
                if (result_msg.data.length) {
                if (result_msg.position === pos.LEFT) {
                    current = [...result_msg.data, ...current];
                } else if (result.msg.position === pos.RIGHT) {
                    current = [...current, ...result_msg.data];
                }
            }
            num_fragment++;
            if (num_fragment == 3) {
                result = current;
            }
        }


    =}

    reaction(result_msg) -> result {=
        if (result_msg.data.length) {
            if (result_msg.position === pos.LEFT) {
                current = [...result_msg.data, ...current];
            } else if (result.msg.position === pos.RIGHT) {
                current = [...current, ...result_msg.data];
            }
        }
        num_fragment++;
        if (num_fragment == 3) {
            result = current;
            //const temp:result_msg;
            //temp.isValid = true;
            //temp.data = current;
            //result = temp;
        }
    =}

}


reactor Source(num_data:number(1000000), max_value:number(0)) {
    
    // runner한테 시그널 받으면 시작
    // array만들고 -> random 값을 하나하나 할당
    // mutation써서 quicksort_unit 하나 만듬(array를 주면 됨)
    
    // 얘한테 데이터 받으면 runner한테 end 시그널 보내면 됨
    
    // runner 한테 받는 포트
    input start:boolean;

    // 메인 quicksort unit 하나한테 받을 거
    input result_msg:{=RESULT_MSG_TYPE=};

    // 메인 quicksort unit 하나한테 명령할 거
    output sort_msg:boolean;

    // runner 한테 보낼 거
    output end:boolean;

    reaction(start) -> sort_msg {=

    =}

    reaction(result_msg) -> end {=

    =}


}

main reactor QuickSort(num_iterations: number(12)) {
    
    runner = new BenchmarkRunner(num_iterations = num_iterations);
    s = new Source();
    u = new QuickSort_Unit(capacity=2048, data={=[4, 1, 3, 2]=}, given_position = {=Pos.INIT=});

    runner.start -> s.start;
    s.sort_msg -> u.sort_msg;
    u.result_msg -> s.result_msg;
    s.end -> runner.end;

}